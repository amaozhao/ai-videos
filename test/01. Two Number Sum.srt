1
00:00:01,635 --> 00:00:03,778
Hey everybody, welcome to Algo Expert.

2
00:00:03,778 --> 00:00:08,144
In this video, we're going to be covering the question of the two-number sum.

3
00:00:08,144 --> 00:00:17,136
This question basically gives you an array of distinct integer values, meaning that no number in this array is repeated.

4
00:00:18,128 --> 00:00:25,312
And it also gives you a separate integer value that represents a target sum.

5
00:00:25,312 --> 00:00:38,100
And what you have to do is write a function that's going to find whether or not there's a pair of numbers in this array that you're given that sums up to the target sum.

6
00:00:38,100 --> 00:00:41,863
So in this example, we've got the numbers 3, 5, negative 4, 8, 11, 1, negative 1, 6.

7
00:00:41,863 --> 00:00:43,203
And we've got the target sum 10.

8
00:00:47,632 --> 00:00:55,414
We want to find if there's a pair of two numbers here that sum up to 10, and there is.

9
00:00:55,414 --> 00:00:59,875
We can have the numbers 11 and negative 1, which do indeed sum up to 10.

10
00:00:59,875 --> 00:01:01,656
11 plus negative 1 is equal to 10.

11
00:01:07,130 --> 00:01:19,575
So I really  this question because it's the first of a few of its type, meaning on algoexpert.io, you'll actually find two other questions in the array section or category.

12
00:01:19,575 --> 00:01:21,896
One of them is called three number sum.

13
00:01:21,896 --> 00:01:23,817
The other one is called four number sum.

14
00:01:23,817 --> 00:01:34,081
And they're very similar to this question, except they ask you to find a triplet that sums up to a target sum or a quadruplet, four numbers.

15
00:01:34,081 --> 00:01:36,262
But this question is the easiest of the three.

16
00:01:37,210 --> 00:01:38,792
It only involves two numbers.

17
00:01:38,792 --> 00:01:46,259
That being said, it's important to understand this one because it'll teach you a lot and it'll prepare you for these tougher questions.

18
00:01:46,259 --> 00:01:47,380
So how do we do this?

19
00:01:47,380 --> 00:01:54,467
How do we go about implementing an algorithm that'll, , traverse this array and somehow find the solution?

20
00:01:55,915 --> 00:02:04,289
The first thought that you might have is to kind of use two for loops and traverse the array twice to find the sum.

21
00:02:04,289 --> 00:02:05,851
And that would work, ?

22
00:02:05,851 --> 00:02:10,258
You could traverse the array once, go through each of the numbers individually,

23
00:02:10,919 --> 00:02:17,504
And then at each number, traverse through the rest of the array and try to find the sum.

24
00:02:17,504 --> 00:02:28,352
In other words, you could start at 3 and traverse all the other numbers here and see if adding any of these numbers to 3 yields 10.

25
00:02:28,352 --> 00:02:33,796
Then you move on to 5 and you traverse all the other numbers and see if adding any of them to 5 gives 10.

26
00:02:33,796 --> 00:02:35,938
And so on and so forth, ?

27
00:02:39,065 --> 00:02:43,611
But the thing is, that's not very optimal from a time point of view, ?

28
00:02:43,611 --> 00:02:48,577
That's going to take O then squared time because you're going to be doing two for loops.

29
00:02:48,577 --> 00:02:53,482
So perhaps a better way of solving this here is to use a hash table.

30
00:02:53,482 --> 00:02:57,047
That's going to cost extra space, but it might make our algorithm faster.

31
00:02:57,870 --> 00:02:59,972
So what do I mean by using a hash table?

32
00:02:59,972 --> 00:03:16,229
Well, basically, we can store, we can traverse our array here and store every number that we see in a hash table, which is going to allow us to then access these numbers in constant time through that hash table.

33
00:03:17,063 --> 00:03:18,864
So I'll write in green here.

34
00:03:18,864 --> 00:03:29,867
Let's say we have a hash table at the top, which you can represent as a Python dictionary or a JavaScript object, whatever you want in your language of choice.

35
00:03:29,867 --> 00:03:45,493
So now that we have this hash table of numbers, we're going to traverse our array, and at each of the numbers that we traverse, at each of the numbers that we stop at, we're going to check if

36
00:03:46,424 --> 00:03:56,509
the number needed to sum up to the target value, which is 10, is stored in this hash table.

37
00:03:56,509 --> 00:03:59,391
So in other words, we've got our target sum, ?

38
00:03:59,391 --> 00:04:05,254
We've got target sum is equal to 10.

39
00:04:07,062 --> 00:04:12,946
And whenever we're traversing the array, we've got a current num.

40
00:04:12,946 --> 00:04:15,087
Let's call it current num.

41
00:04:15,087 --> 00:04:23,433
Current num, which is equal to x. x is whatever number we're at as we traverse the array.

42
00:04:23,433 --> 00:04:32,599
And so we want to find y, the number y, such that x plus y is equal to 10.

43
00:04:34,338 --> 00:04:48,231
Or in other words, we can isolate y to be y is equal to 10 minus x. So basically, as we traverse the array, we have the value 10, which is our target sum.

44
00:04:48,231 --> 00:04:52,435
We have the value x, which is whatever number we're currently at.

45
00:04:53,717 --> 00:05:19,362
And all we need to do is apply this formula or solve this equation to find y. And then we say if y is in our hash table, and we can do that in constant time, accessing y in the hash table, if it is in the hash table, then we just return x and y. Otherwise, we keep traversing the array and we just make sure to store x in the hash table.

46
00:05:20,615 --> 00:05:23,776
So here, let's see how this is going to look.

47
00:05:23,776 --> 00:05:37,842
We start at the number 3, and we say, OK, y is going to be equal to, we're going to write it in, let's write it in white, y is going to be equal to 10 minus 3.

48
00:05:37,842 --> 00:05:41,444
In other words, y is going to be equal to 7.

49
00:05:41,444 --> 00:05:44,205
Is 7 in our hash table?

50
00:05:44,205 --> 00:05:44,785
No, it's not.

51
00:05:45,715 --> 00:05:49,137
So we haven't found the two number sum so far.

52
00:05:49,137 --> 00:05:52,239
But what we can do now is we can store 3 in our hash table.

53
00:05:52,239 --> 00:05:57,443
We can store 3 to be true, or whatever value you want to store it as.

54
00:05:57,443 --> 00:06:02,726
True here just kind of indicates that yes, 3 is present in our array.

55
00:06:02,726 --> 00:06:04,947
So now we move on to 5.

56
00:06:04,947 --> 00:06:13,072
And we say, OK, if we have the number 5, let's solve for y. So here we're going to say 10 minus 5.

57
00:06:15,864 --> 00:06:18,126
is equal to 5.

58
00:06:18,126 --> 00:06:20,869
And is 5 in our hash table?

59
00:06:20,869 --> 00:06:22,570
No, it's not.

60
00:06:22,570 --> 00:06:24,952
So we skip this.

61
00:06:24,952 --> 00:06:26,994
We haven't found our two numbers sum.

62
00:06:26,994 --> 00:06:34,121
And all we're going to do is store the number 5 here in our hash table as true.

63
00:06:34,121 --> 00:06:36,163
So add a couple of commas here.

64
00:06:36,163 --> 00:06:39,326
Then we move on to the number minus 4.

65
00:06:39,326 --> 00:06:40,387
And we solve for y.

66
00:06:41,245 --> 00:06:53,473
So we say, is 10 minus negative 4 equal, so 10 minus negative 4 is going to be equal to 14.

67
00:06:53,473 --> 00:06:55,595
Is 14 in our hash table?

68
00:06:55,595 --> 00:06:56,676
No, it's not.

69
00:06:56,676 --> 00:07:04,401
So we just store negative 4 to be true in our hash table.

70
00:07:04,401 --> 00:07:05,101
Then we get to this 8.

71
00:07:06,621 --> 00:07:15,824
We solve for y, so 10 minus 8 is going to be equal to 2.

72
00:07:15,824 --> 00:07:17,585
Is 2 in our hash table?

73
00:07:17,585 --> 00:07:18,205
No, it's not.

74
00:07:18,205 --> 00:07:21,046
We only have 3, 5, and negative 4.

75
00:07:21,046 --> 00:07:24,187
So we can skip this and we can just store 8.

76
00:07:25,878 --> 00:07:28,959
as true, and you kind of get the idea now, ?

77
00:07:28,959 --> 00:07:31,139
So the rest of this should go pretty fast.

78
00:07:31,139 --> 00:07:37,181
We go to 11, solve for y, 10 minus 11 is going to be equal to negative 1.

79
00:07:37,181 --> 00:07:43,163
So that's not going to be, is negative 1 in our hash table?

80
00:07:43,163 --> 00:07:45,683
No, it's not, at least not yet.

81
00:07:45,683 --> 00:07:46,564
So we just store 11.

82
00:07:46,564 --> 00:07:49,004
Then we move on to this one.

83
00:07:51,555 --> 00:07:55,456
We do 10 minus 1, that's going to be equal to 9.

84
00:07:55,456 --> 00:08:00,278
9 is not in our hash table, so we just store 1.

85
00:08:00,278 --> 00:08:03,339
And now we get to

86
00:08:06,983 --> 00:08:08,503
the number that we care about.

87
00:08:08,503 --> 00:08:10,344
We get to negative 1.

88
00:08:10,344 --> 00:08:16,945
So we can calculate 10 minus 10 minus negative 1.

89
00:08:16,945 --> 00:08:18,646
That's going to be equal to 11.

90
00:08:18,646 --> 00:08:27,148
And now if we check for the number 11 in our hash table, well we'll notice that we have it here, ?

91
00:08:28,008 --> 00:08:34,470
And so because 11 is in our hash table, that means that we know we've traversed it in our array.

92
00:08:34,470 --> 00:08:36,451
We've traversed through it.

93
00:08:36,451 --> 00:08:41,153
So now we can just return 11 and negative 1.

94
00:08:41,153 --> 00:08:41,613
And we're done.

95
00:08:41,613 --> 00:08:51,796
So now we can just say return 11 and negative 1.

96
00:08:51,796 --> 00:08:52,676
And we're done.

97
00:08:52,676 --> 00:08:54,177
We've found our answer.

98
00:08:55,255 --> 00:09:00,297
So how are we doing in terms of space-time complexity analysis?

99
00:09:00,297 --> 00:09:04,858
Well, let's write it at the top left here.

100
00:09:04,858 --> 00:09:15,081
The time complexity here is just going to be O of n time, where n represents the length of our input array.

101
00:09:15,081 --> 00:09:16,281
Why is it just O of n time?

102
00:09:16,281 --> 00:09:18,662
Well, we're traversing our array only once.

103
00:09:19,812 --> 00:09:27,297
And at each number, all we're doing is calculating y, solving for y. That's just a constant time operation.

104
00:09:27,297 --> 00:09:29,398
We're just doing a calculation.

105
00:09:29,398 --> 00:09:31,379
We have the target sum.

106
00:09:31,379 --> 00:09:37,022
We have the number x here, which is whatever the current number we're at.

107
00:09:37,022 --> 00:09:41,725
And then we're just accessing values in a hash table, which is going to run in constant time.

108
00:09:41,725 --> 00:09:44,547
So in total, time complexity is O then.

109
00:09:45,826 --> 00:09:54,608
Now the space complexity is also going to be O of n because we are adding values to a hash table.

110
00:09:54,608 --> 00:10:02,230
And so here we kind of saw that we went all the way to this negative 1, which was kind of the before last number in our array.

111
00:10:02,230 --> 00:10:09,032
So we did store a bunch of values which kind of neared n values in our hash table.

112
00:10:09,892 --> 00:10:20,539
So the space complexity is going to be O of n. If we had done this using just two for loops without a hash table, then we probably wouldn't have used additional space.

113
00:10:20,539 --> 00:10:22,860
We would have gotten constant space.

114
00:10:22,860 --> 00:10:31,326
But we would have gotten O of n squared time because of the double for loops and the sort of double iteration through the array.

115
00:10:31,326 --> 00:10:34,367
Anyway, that's it for the conceptual overview of this algorithm.

116
00:10:34,367 --> 00:10:36,889
Let's see what it looks  in code.

117
00:10:37,879 --> 00:10:54,025
So before we dive into the code walkthrough, I have to apologize because I just realized that I totally forgot while I was filming the video to mention a third way that we can solve this problem that is definitely worth mentioning and worth covering.

118
00:10:54,025 --> 00:10:55,545
So I'm going to do it now.

119
00:10:55,545 --> 00:11:02,168
It doesn't use a hash table and it's more optimal than the first solution using double for loops.

120
00:11:02,168 --> 00:11:03,068
So let's dive into it.

121
00:11:04,238 --> 00:11:07,281
Basically, we had this array of numbers, ?

122
00:11:07,281 --> 00:11:11,784
And when we were given the array of numbers, we weren't told anything about it.

123
00:11:11,784 --> 00:11:15,047
In other words, the array wasn't necessarily sorted.

124
00:11:15,047 --> 00:11:27,877
But we can solve this problem more optimally without using a hash table by first sorting the array, more optimally than the solution with two for loops.

125
00:11:27,877 --> 00:11:30,920
So if we sort the array, here I've got the sorted array,

126
00:11:32,476 --> 00:11:41,287
We know that good sorting algorithms  quick sort or merge sort or heap sort will take O of n log n time.

127
00:11:41,287 --> 00:11:51,420
So we can have a time complexity of O of n log n. And then we can actually find the answer, which is going to be 11 and negative 1 here, in O of n time.

128
00:11:52,689 --> 00:12:00,691
And because we can find it in O of n time, we have a total space or a total time complexity of O of n log n from the sorting at the beginning.

129
00:12:00,691 --> 00:12:02,731
And we don't use any additional space.

130
00:12:02,731 --> 00:12:04,432
So O of one space.

131
00:12:04,432 --> 00:12:07,412
So let's dive into actually how this works.

132
00:12:07,412 --> 00:12:17,894
Basically, what we can do is once we've sorted this array, and by the way, the same logic is applied to another question on the website, the one called three number sum.

133
00:12:17,894 --> 00:12:20,435
So if you're interested, definitely go check that one out as well.

134
00:12:21,335 --> 00:12:31,963
So what we can do is we can put a left pointer, initialize it to be under the first number in the array.

135
00:12:31,963 --> 00:12:35,626
So we've got a big L here representing a left pointer.

136
00:12:35,626 --> 00:12:42,392
And we can put a  pointer under the very last number in the array, in this case 11.

137
00:12:43,966 --> 00:12:50,790
And so what we can do is we can sum up the two numbers that L and R point to.

138
00:12:50,790 --> 00:13:01,215
So we have negative 4 plus 11.

139
00:13:01,215 --> 00:13:07,699
And once we have this sum, we can compare the sum to our number.

140
00:13:07,699 --> 00:13:09,540
So this sum is going to be 7.

141
00:13:09,540 --> 00:13:12,281
And so we can compare 7 to 10.

142
00:13:15,140 --> 00:13:18,403
Now, is 7 equal to 10?

143
00:13:18,403 --> 00:13:19,244
No, it's not.

144
00:13:19,244 --> 00:13:21,245
So this is not a valid sum, ?

145
00:13:21,245 --> 00:13:24,388
Negative 4 and 11 are not a valid sum.

146
00:13:24,388 --> 00:13:29,713
But what we can say now is we know that 7 is less than 10, ?

147
00:13:29,713 --> 00:13:40,442
And if 7 is less than 10 and all of our numbers here are in sorted order, then what would happen if we were to move the  pointer?

148
00:13:41,490 --> 00:13:53,200
Well, if we were to move the  pointer to the left,  here, to this 8, we know that this 8 is less than 11 because the array is sorted.

149
00:13:53,200 --> 00:14:01,106
And because 8 is less than 11, then our new sum here is going to be even smaller than 7, which is already smaller than 10.

150
00:14:02,266 --> 00:14:12,273
So instead of moving the  pointer to the left, we know that we should move the left pointer to the , because we want to try to have a greater sum.

151
00:14:12,273 --> 00:14:18,717
And so if we move the left pointer to the , then we get this negative 1.

152
00:14:18,717 --> 00:14:28,124
And so we can update our sum to be negative 1 plus 11 equals to 10.

153
00:14:28,124 --> 00:14:30,986
And now we have our actual answer, because 10 is equal to 10.

154
00:14:32,098 --> 00:14:39,463
But now here, let's try to come up with a different example to make this more interesting.

155
00:14:39,463 --> 00:14:43,625
Let's assume that our answer had been 16.

156
00:14:43,625 --> 00:14:44,846
So 11 plus 5.

157
00:14:44,846 --> 00:14:46,667
Or rather, no, not 11 plus 5.

158
00:14:46,667 --> 00:14:48,308
Let's assume that it had been 13.

159
00:14:48,308 --> 00:14:48,768
8 plus 5.

160
00:14:56,809 --> 00:15:10,934
So if we were looking for the number 13, and the answer was 8 plus 5, 8 plus 5, then what we could do is we would have here the sum 10, and 10 would be smaller than 13.

161
00:15:21,253 --> 00:15:34,824
So we'd once again move the left pointer to the  by 1, because we know that moving the  pointer to the left would give us a smaller sum, which would be smaller than 10, which would be smaller than 13 for sure.

162
00:15:34,824 --> 00:15:36,485
So we move the left pointer.

163
00:15:36,485 --> 00:15:43,110
Now we've got 1 plus 11 is going to be equal to 12.

164
00:15:43,110 --> 00:15:45,913
So we compare 12 to our target, which is 13.

165
00:15:48,207 --> 00:15:49,788
12 is less than 13.

166
00:15:49,788 --> 00:15:52,869
So once again, we have a sum that is too small.

167
00:15:52,869 --> 00:15:57,471
So we can move the left pointer to the .

168
00:15:57,471 --> 00:15:58,092
Now we have 3.

169
00:15:58,092 --> 00:16:02,654
So we sum 3 and 11.

170
00:16:02,654 --> 00:16:04,074
And we can erase this.

171
00:16:04,074 --> 00:16:09,917
3 plus 11 is going to be equal to 14.

172
00:16:09,917 --> 00:16:13,078
And now 14 is greater than 13.

173
00:16:13,078 --> 00:16:15,720
So our sum is bigger, ?

174
00:16:15,720 --> 00:16:16,560
Our sum is too big.

175
00:16:18,059 --> 00:16:19,299
So what can we do?

176
00:16:19,299 --> 00:16:24,881
We know that if we move the left pointer to the , we're going to have a number that's bigger.

177
00:16:24,881 --> 00:16:28,242
We're going to have a greater sum, so we don't want that.

178
00:16:28,242 --> 00:16:33,964
We know that moving the left pointer to the left doesn't do anything because we've already tried all these numbers.

179
00:16:33,964 --> 00:16:39,386
So what we do is we move this time around the  pointer to the left.

180
00:16:39,386 --> 00:16:41,046
So now we've got 3 and 8.

181
00:16:41,046 --> 00:16:43,467
8 is smaller than 11, so we're going to have a smaller sum.

182
00:16:44,623 --> 00:16:50,307
So we can update this 11 here to be 8.

183
00:16:50,307 --> 00:16:55,051
And 3 plus 8 is going to be equal to 11.

184
00:16:55,051 --> 00:16:56,993
So is 11 equal to 13?

185
00:16:56,993 --> 00:16:58,133
No, it's not.

186
00:16:58,133 --> 00:16:59,434
It's less than 13.

187
00:16:59,434 --> 00:17:03,698
So again, this time around, we're going to want to move the left pointer to the .

188
00:17:04,587 --> 00:17:16,575
just to make sure that we're on the same page, the reason we don't want to move the  pointer to the , which would be a bigger number, is because we've already calculated sums using this number 11, and we eliminated all of them.

189
00:17:16,575 --> 00:17:19,077
So we want to move the left pointer.

190
00:17:19,077 --> 00:17:24,180
So we move the left pointer to the , now we've got 5 plus 8.

191
00:17:24,180 --> 00:17:26,982
So 5 plus 8.

192
00:17:26,982 --> 00:17:32,066
And 5 plus 8 is going to give us 13, the number that we want.

193
00:17:33,064 --> 00:17:36,706
And that is our answer.

194
00:17:36,706 --> 00:17:42,048
And so the reason this is a really nice way to solve this problem is because we don't use additional space.

195
00:17:42,048 --> 00:17:49,711
, we just have a left pointer and a  pointer, but that's kind of, that's not kind of, that is constant space.

196
00:17:49,711 --> 00:17:52,713
We don't use an extra hash table or anything.

197
00:17:52,713 --> 00:18:02,637
And in terms of time, we actually run in O of n log n because that's how long a great sorting algorithm  quick sort would run.

198
00:18:03,812 --> 00:18:13,178
And the actual algorithm that we just described here with the left and  pointers runs in O then time.

199
00:18:13,178 --> 00:18:24,405
Because at the most, we're going to be moving the left pointer to the  every time, the  pointer to the left every time, and eventually they get equal to each other.

200
00:18:24,405 --> 00:18:28,788
And in total, all we've done is go through all the numbers

201
00:18:29,603 --> 00:18:36,989
, once or twice, and so that converges to O of n time.

202
00:18:36,989 --> 00:18:53,642
Therefore, we can write the time to be O of n log n, and the space can be written as O of 1, which is constant space.

203
00:18:55,604 --> 00:18:58,505
So this is a really cool way to solve this algorithm.

204
00:18:58,505 --> 00:19:01,706
Once again, I apologize for having forgotten about it.

205
00:19:01,706 --> 00:19:04,806
It's definitely covered in the three number sum question.

206
00:19:04,806 --> 00:19:13,189
So definitely check it out if you want to re-see how it works and in the context of that question, which is a bit more complicated.

207
00:19:13,189 --> 00:19:18,410
And now let's actually dive into the code walkthrough of all these solutions.

208
00:19:19,694 --> 00:19:23,178
All , so we've got our two-number sum function defined.

209
00:19:23,178 --> 00:19:30,545
It takes in an array of distinct integers and an integer value representing the target sum.

210
00:19:30,545 --> 00:19:39,595
And so we're first going to type out the solution using the two for loops, which is going to run in O of n squared time, where n represents the length of the array.

211
00:19:40,522 --> 00:19:44,904
For that solution, all we have to do is literally implement two for loops.

212
00:19:44,904 --> 00:19:53,249
So we'll say for i in range len of array minus 1.

213
00:19:53,249 --> 00:19:57,751
We want to go all the way to the before last value in the array.

214
00:19:57,751 --> 00:20:09,578
And then we can say current num, or rather first num, we can kind of declare our first num variable is going to be equal to array of i.

215
00:20:10,833 --> 00:20:21,803
And then we can say for j in range i plus 1 len of array, here we're iterating through all the rest of the numbers in the array.

216
00:20:21,803 --> 00:20:32,113
We can say second num is going to be equal to array of j. And here it's important that j goes all the way to the end of the array, ?

217
00:20:33,436 --> 00:20:48,744
And then we say if firstNum plus secondNum equals targetSum, then just return an array of firstNum and secondNum.

218
00:20:48,744 --> 00:20:51,106
And we're done, ?

219
00:20:51,106 --> 00:20:59,370
Then at the end, we can here return an empty array if we've never hit this return statement in the double for loop.

220
00:21:01,492 --> 00:21:04,373
So that is the first way of solving this problem.

221
00:21:04,373 --> 00:21:12,876
And that's going to run in O of n squared time and O of one space, because we're not using a hash table.

222
00:21:12,876 --> 00:21:15,937
We're not using any other kinds of arrays or anything.

223
00:21:15,937 --> 00:21:20,798
All we're doing is storing two extra variables, which we don't even need to do here.

224
00:21:20,798 --> 00:21:23,319
It's just for readability purposes.

225
00:21:23,319 --> 00:21:28,761
And then at the end, we're returning either an empty array or an array of two values.

226
00:21:30,449 --> 00:21:38,879
All , now, the way that we really covered in the conceptual overview, which uses the hash cable, this is going to be a bit different.

227
00:21:38,879 --> 00:21:44,565
So toNumberSumArrayTargetSum has the same two parameters.

228
00:21:44,565 --> 00:21:46,327
Let's comment this first one out.

229
00:21:47,476 --> 00:21:51,719
So this one, we're going to start by initializing our hash table.

230
00:21:51,719 --> 00:21:57,022
We're going to use just a dictionary here in Python or a JavaScript object.

231
00:21:57,022 --> 00:22:02,185
And we're just going to call it nums, short for numbers.

232
00:22:02,185 --> 00:22:04,227
And then we're going to start iterating through our array.

233
00:22:04,227 --> 00:22:12,352
So we're going to say for num in array, if target sum minus num

234
00:22:13,594 --> 00:22:16,655
is in our numbers hash table.

235
00:22:16,655 --> 00:22:18,795
Now what is target sum minus num?

236
00:22:18,795 --> 00:22:20,156
That's y, ?

237
00:22:20,156 --> 00:22:32,278
That's the value in the conceptual overview that we called y. This is basically our equation, y equals target sum minus x. That was the equation that we cover in the conceptual overview.

238
00:22:32,278 --> 00:22:38,940
So if target sum minus num, which is the y value, is present in our num's hash table,

239
00:22:39,917 --> 00:22:50,463
We'll then just return target sum minus num, comma, num.

240
00:22:50,463 --> 00:22:56,486
Otherwise, nums of num is going to be equal to true.

241
00:22:56,486 --> 00:23:05,131
Otherwise, we just store our current number in the hash table, and we can just store it as true or whatever you want to put here.

242
00:23:05,131 --> 00:23:06,892
I think true makes the most sense.

243
00:23:08,428 --> 00:23:16,420
And then at the end, if we never hit this return statement, then we're just going to return the empty array.

244
00:23:17,730 --> 00:23:31,604
And so here, by the way, it might be for readability purposes, it might be better to declare, , potential match equals target sum minus num.

245
00:23:31,604 --> 00:23:38,631
And then here we can kind of replace target sum minus num with potential match.

246
00:23:40,459 --> 00:23:41,781
And we're done.

247
00:23:41,781 --> 00:23:53,253
This is going to run in O of n time, not n squared time, but it will also run in O of n space because we're storing these values in the hash table.

248
00:23:55,115 --> 00:23:57,778
So I hope this video was helpful.

249
00:23:57,778 --> 00:24:02,304
I hope it taught you how to solve this algorithm.

250
00:24:02,304 --> 00:24:06,269
And really, I hope it showed you how you can use hash cable to your advantage.

251
00:24:06,269 --> 00:24:13,258
Oftentimes, hash tables will make your algorithm use up a bit more space, but run faster and more efficiently.

252
00:24:14,119 --> 00:24:31,373
and they're oftentimes going to be worth using, especially in more complicated algorithms that might use up space no matter what, in which case using an additional hash table won't really matter from a space point of view, but will actually help you from a time point of view.

253
00:24:31,373 --> 00:24:33,094
All , that's it for this video.

254
00:24:33,094 --> 00:24:34,175
I'll see you in the next one.

255
00:24:35,092 --> 00:24:37,454
All , so the video is not over yet.

256
00:24:37,454 --> 00:24:44,742
We still have this third solution that I mentioned earlier in the conceptual overview to implement in code.

257
00:24:44,742 --> 00:24:50,868
So let's comment this one out and let's go over this third solution.

258
00:24:52,267 --> 00:24:55,230
So it's going to take the same arguments, ?

259
00:24:55,230 --> 00:24:58,773
But at the very beginning, what we're going to do is we're going to sort the array.

260
00:24:58,773 --> 00:25:13,786
So we're going to just use, , our built-in Python sorting function and assume or hope rather that it uses an optimal sorting algorithm  quick sort or merge sort and runs an O of n log n time.

261
00:25:14,248 --> 00:25:16,431
where n is the length of the array.

262
00:25:16,431 --> 00:25:30,288
And so then we can initialize our left pointer to be equal to zero, the first value in the array, and our  pointer to be equal to the final value in the array, or the final index in the array, len of array minus one.

263
00:25:31,670 --> 00:25:55,588
So then we can have a while loop, and we can say while left is less than , so while the two pointers don't overlap, or while the left one is not past the  one, the current sum is going to be equal to array of left plus array of .

264
00:25:57,730 --> 00:26:17,415
And if the current sum is equal to, whoops, we don't need parentheses here, if the current sum is equal to the target sum, then we can just return left and or rather array of left and array of , ?

265
00:26:17,415 --> 00:26:19,516
The two numbers that we have.

266
00:26:20,794 --> 00:26:31,787
And then we can say lf, and here let me make a bit of space, lf current sum is less than the target sum.

267
00:26:31,787 --> 00:26:36,733
If our current sum is less than the target sum, then we want to increase the left pointer.

268
00:26:36,733 --> 00:26:38,395
So we can say left plus equal to 1.

269
00:26:39,777 --> 00:26:54,116
and then elif the current sum is greater than target sum  plus equal or  sorry minus equal to one because then we want to move the  pointer to the left by one position

270
00:26:56,367 --> 00:26:59,269
And that's it.

271
00:26:59,269 --> 00:27:02,771
Otherwise, we can just return the empty array.

272
00:27:02,771 --> 00:27:22,385
If we get out of this while loop without having hit this if statement here on line 28, and without having returned two numbers, then that means that we didn't have two numbers that summed up to the actual sum, the target sum, and we return the empty array.

273
00:27:22,385 --> 00:27:22,665
So this

274
00:27:25,088 --> 00:27:32,273
O of n log n time, and it's going to run in constant space.

275
00:27:32,273 --> 00:27:42,620
So you can kind of see that the space complexity here is as good as the first algorithm with the double for loops, better than the one with the hash table.

276
00:27:44,117 --> 00:27:53,764
And the time complexity is better, definitely better than the one with the double for loops, but a bit worse than the one with the hash table.

277
00:27:53,764 --> 00:27:59,448
So here, if you were in an interview and you came up with all three of these solutions, you'd be doing really well.

278
00:27:59,848 --> 00:28:03,529
You could talk with your interviewer about the trade-offs.

279
00:28:03,529 --> 00:28:11,292
Maybe you value space more than time, in which case you'd use this last solution.

280
00:28:11,292 --> 00:28:17,115
Otherwise, you'd use probably the solution with the hash table if you valued time the most.

281
00:28:17,115 --> 00:28:23,517
So I hope this video was informative for the second time around, and I'll see you in the next one.

