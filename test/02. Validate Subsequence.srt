1
00:00:00,892 --> 00:00:03,355
Hey everybody, welcome to Algo Expert.

2
00:00:03,355 --> 00:00:08,621
In this video, we're going to cover the question of validating a subsequence.

3
00:00:08,621 --> 00:00:18,233
This is a pretty easy and straightforward question, but it is an interesting one, mainly because it deals with a concept that's very popular in coding interviews

4
00:00:18,593 --> 00:00:24,818
and especially in some of the harder coding interview questions that we've got  here on Algo Expert.

5
00:00:24,818 --> 00:00:28,862
And that concept is the concept of a subsequence.

6
00:00:28,862 --> 00:00:30,623
What is a subsequence?

7
00:00:30,623 --> 00:00:40,191
Well, it's a concept that stems from mathematics, and here I'll actually read off the definition of a subsequence from Wikipedia, because I think it's a pretty good definition.

8
00:00:41,032 --> 00:00:54,854
In mathematics, a subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.

9
00:00:55,830 --> 00:01:04,621
So, for example, if you take a look at the array that I've got in front of me here, the one that starts with 5 and that ends with 10, this is an array of integers.

10
00:01:04,621 --> 00:01:06,964
So it's a sequence of integers.

11
00:01:06,964 --> 00:01:10,769
And if you were to remove some of the integers from this sequence,

12
00:01:11,309 --> 00:01:25,713
For example, if you were to remove the integer 22, or maybe if you were to remove none of the integers, maybe you didn't remove 22, the remaining elements would be a subsequence of the original sequence.

13
00:01:26,843 --> 00:01:42,168
And so this question gives us two arrays of integers, and we're told that they're non-empty, and it wants us to write a function that is going to determine whether or not the second array is a valid subsequence of the first one.

14
00:01:42,168 --> 00:01:49,270
So for example here, we have to determine whether or not this array is a valid subsequence of this array.

15
00:01:49,950 --> 00:02:08,132
And another way to think about subsequences when we're dealing with arrays is in order for an array to be a valid subsequence of another array, all of the integers in the potential subsequence have to not only appear in the original array,

16
00:02:08,713 --> 00:02:11,895
But they also have to appear in the same order.

17
00:02:11,895 --> 00:02:14,157
They don't necessarily have to be adjacent.

18
00:02:14,157 --> 00:02:21,942
As you can see here, the numbers 1, 6, negative 1, and 10 do appear in this array, but they're not adjacent.

19
00:02:21,942 --> 00:02:23,623
1 is here, 6 is here.

20
00:02:23,623 --> 00:02:25,544
We've got a couple of integers in between them.

21
00:02:25,544 --> 00:02:28,146
Then here we've got 8 in between negative 1 and 10.

22
00:02:28,966 --> 00:02:33,991
But they do appear in the original array, and they appear in the same order.

23
00:02:33,991 --> 00:02:39,916
They go from 1 to 6 to negative 1 to 10, 1 to 6 to negative 1 to 10.

24
00:02:39,916 --> 00:02:51,948
And so if we were to call our function or the function that we have to write passing in these two arrays, the output of our function would be true because this array is indeed a valid subsequence of this array.

25
00:02:52,922 --> 00:02:54,903
So how do we solve this problem?

26
00:02:54,903 --> 00:03:01,924
Well, the first thing that we should realize is that we're going to have to traverse both arrays that we're given.

27
00:03:01,924 --> 00:03:07,626
We're going to have to traverse the potential subsequence because that's the thing that we're looking for.

28
00:03:07,626 --> 00:03:13,047
We're looking to see if this sequence appears in the first array.

29
00:03:13,047 --> 00:03:21,009
So we're definitely going to have to traverse our entire second array here just because we have to know what integers we're looking for in the first array.

30
00:03:21,748 --> 00:03:31,712
And then we're also going to have to traverse our entire main array because our sequence could basically be located anywhere in the main array.

31
00:03:31,712 --> 00:03:41,876
In other words, the first element in our sequence could very well be the first element in our main array, and the last element in our sequence could very well be the last element in our main array.

32
00:03:41,876 --> 00:03:44,137
And in this case, it actually is.

33
00:03:44,137 --> 00:03:46,238
10 is indeed the last element in our main array.

34
00:03:46,698 --> 00:03:49,681
So we're likely going to have to traverse the entire array.

35
00:03:49,681 --> 00:03:55,707
We might be able to stop early when we're traversing our array if we've found our entire subsequence already.

36
00:03:55,707 --> 00:04:02,393
But the point is the logic of our algorithm will likely involve traversing both of these arrays.

37
00:04:02,393 --> 00:04:05,677
Now the question becomes how do we want to traverse them?

38
00:04:05,677 --> 00:04:10,722
How do we actually find these numbers and in this order in the main array?

39
00:04:11,675 --> 00:04:32,705
Well, one way to think about it is that because the order of the elements in a subsequence and in the original sequence matters, that means that at the very beginning, when we're just starting to look for our potential subsequence, we're really looking for the first element in the potential subsequence.

40
00:04:33,045 --> 00:04:38,347
We're not looking for 6, we're not looking for negative 1, we're not looking for 10, we're looking for 1.

41
00:04:38,347 --> 00:04:45,570
Because if we can't find 1, or if we find other elements before finding 1, that doesn't matter, ?

42
00:04:45,570 --> 00:04:48,131
A subsequence cares about order.

43
00:04:48,131 --> 00:04:51,592
So we're really looking for the first element, which is 1.

44
00:04:51,592 --> 00:05:02,357
So what we're gonna do is we're gonna initialize a pointer underneath the first element of our subsequence, or potential subsequence, and we're gonna say, let's traverse our main array

45
00:05:02,997 --> 00:05:08,162
until we find this first element that our pointer is pointing to.

46
00:05:08,162 --> 00:05:12,786
And so we're going to put another pointer underneath the first element in our main array.

47
00:05:12,786 --> 00:05:20,972
And here, as you might imagine, when we're actually going to write the code for this algorithm, this might be a simple for loop or a simple while loop.

48
00:05:20,972 --> 00:05:29,480
But the point is we're iterating through this array by looking at elements and seeing if we find the first element in our potential subsequence.

49
00:05:29,920 --> 00:05:31,622
So here we've got a 5.

50
00:05:31,622 --> 00:05:33,184
Is 5 equal to 1?

51
00:05:33,184 --> 00:05:34,165
No, it's not.

52
00:05:34,165 --> 00:05:38,210
So what we're going to do is we're just going to move our pointer to the next element.

53
00:05:38,210 --> 00:05:44,878
We're going to move along in our first array until we find this first element from our potential subsequence.

54
00:05:44,878 --> 00:05:46,620
It turns out here that the second element

55
00:05:47,040 --> 00:05:48,681
is the one we're looking for.

56
00:05:48,681 --> 00:05:52,064
This is a one, and the element that we're looking for is one.

57
00:05:52,064 --> 00:05:59,109
So at this point what we do is we say, , we found the first element in our potential subsequence.

58
00:05:59,109 --> 00:06:01,331
Now we need to look for the second element.

59
00:06:01,331 --> 00:06:03,473
We need to look for the number six.

60
00:06:03,473 --> 00:06:09,337
So what we're going to do is we're going to move our pointer in our potential subsequence to the next element.

61
00:06:09,337 --> 00:06:11,099
So the pointer now points to six.

62
00:06:11,699 --> 00:06:15,683
And we're going to move our pointer in our main sequence forward.

63
00:06:15,683 --> 00:06:22,290
And the reason we're moving forward and we don't have to go back or anything is because, once again, order matters.

64
00:06:22,290 --> 00:06:25,873
We found the first element in our subsequence here.

65
00:06:25,873 --> 00:06:32,279
That means that any future elements that we're looking for, we're looking to find them after this element.

66
00:06:32,279 --> 00:06:33,481
We don't want to go back.

67
00:06:33,481 --> 00:06:34,842
We don't want to stay here, obviously.

68
00:06:35,122 --> 00:06:36,744
we want to keep going forward.

69
00:06:36,744 --> 00:06:40,887
So we're going to move along forward here, and now we're going to do the same thing.

70
00:06:40,887 --> 00:06:50,276
We're going to compare the element that we're at in our main array to the element that our pointer in our potential subsequence is pointing at and see if they match.

71
00:06:50,276 --> 00:06:52,198
Is 22 equal to 6?

72
00:06:52,198 --> 00:06:53,079
No, it's not.

73
00:06:53,079 --> 00:06:56,342
So we're going to move forward to 25.

74
00:06:56,342 --> 00:06:57,863
Is 25 equal to 6?

75
00:06:57,863 --> 00:06:58,604
No, it's not.

76
00:06:58,604 --> 00:06:59,845
So we're going to keep moving forward.

77
00:07:00,575 --> 00:07:02,457
Is six equal to six?

78
00:07:02,457 --> 00:07:03,118
Yes it is.

79
00:07:03,118 --> 00:07:04,138
We've got a match.

80
00:07:04,138 --> 00:07:09,103
So at this point we do exactly what we did when we found the first element here with the two ones.

81
00:07:09,103 --> 00:07:12,426
We move the pointer in our subsequence forward.

82
00:07:12,426 --> 00:07:15,729
So this is now going to point to negative one.

83
00:07:15,729 --> 00:07:18,292
And then we keep moving along in our main array.

84
00:07:18,292 --> 00:07:20,554
So here we're now going to be under the negative one.

85
00:07:20,974 --> 00:07:23,616
It turns out that we've got another match immediately.

86
00:07:23,616 --> 00:07:25,477
Negative one is equal to negative one.

87
00:07:25,477 --> 00:07:31,200
So now we can move this pointer along to the  and move this pointer along to the .

88
00:07:31,200 --> 00:07:44,808
And to clarify here, what we're effectively saying is that we have found one, six and negative one in this order, not necessarily adjacent, but in this order in the main array.

89
00:07:44,808 --> 00:07:45,008
.

90
00:07:45,008 --> 00:07:47,570
And now we're looking for 10, which is the next

91
00:07:47,930 --> 00:07:52,034
number in our potential subsequence, and it happens to be the last number.

92
00:07:52,034 --> 00:07:53,536
So is 10 equal to 8?

93
00:07:53,536 --> 00:07:54,637
No, it's not.

94
00:07:54,637 --> 00:08:06,930
Then we move this pointer to the next element, which is 10, and at this point 10 is equal to 10, so we move our pointer here in the subsequence, we move it forward, and we realize that we are past

95
00:08:08,531 --> 00:08:10,572
the bound of our subsequence.

96
00:08:10,572 --> 00:08:12,593
There are no more elements here.

97
00:08:12,593 --> 00:08:15,014
So we can basically stop the algorithm.

98
00:08:15,014 --> 00:08:20,077
And here, this is sort of what I hinted at earlier, we could have had more elements in the main array.

99
00:08:20,077 --> 00:08:21,738
We could have had maybe 11 here.

100
00:08:21,738 --> 00:08:23,599
We could have had another number, 7.

101
00:08:23,599 --> 00:08:32,583
But the point is we wouldn't have had to keep on going to the 11 or to the 7 because we finished traversing through our entire subsequence.

102
00:08:32,583 --> 00:08:35,705
We found the entire subsequence so we can stop early.

103
00:08:36,578 --> 00:08:38,058
And so that's our algorithm.

104
00:08:38,058 --> 00:08:43,260
The algorithm has us traverse both arrays that were given simultaneously.

105
00:08:43,260 --> 00:08:48,801
And we're effectively moving forward in the main array without stopping.

106
00:08:48,801 --> 00:08:57,823
The only thing that we do is at every point or at every element, we check if that element matches the current element that we're looking for in the subsequence.

107
00:08:58,463 --> 00:09:03,531
And in the subsequence, we only move forward when we find a match.

108
00:09:03,531 --> 00:09:11,242
Until we find a match for the current element that we're at, we don't move forward in the subsequence, we only move forward in the main array.

109
00:09:12,130 --> 00:09:16,432
So as far as complexity analysis goes, let's start with the time complexity.

110
00:09:16,432 --> 00:09:24,976
The time complexity of this algorithm is going to be O of n time, where n is the length of the main array.

111
00:09:24,976 --> 00:09:30,179
The reason it's O of n time is because we're going to have to traverse through the entire main array.

112
00:09:30,179 --> 00:09:37,142
we said, we iterate through it without stopping, and all that we do is we check if there's a match with the current element,  for instance,

113
00:09:37,562 --> 00:09:45,387
number 10 here and the element that we're at in the subsequence, the comparison of the numbers is a constant time operation.

114
00:09:45,387 --> 00:09:51,872
Now you might say, but wait a second, sometimes we're gonna stop early once we've found the entire subsequence.

115
00:09:51,872 --> 00:09:54,594
But that's only gonna be in certain cases.

116
00:09:54,594 --> 00:09:59,257
It's only gonna be if the subsequence ends before the end of the main array.

117
00:09:59,797 --> 00:10:04,762
here when we added 11 and 7, yeah, we didn't traverse through the entire main array.

118
00:10:04,762 --> 00:10:11,588
We said we could stop at 10 because we found the entire subsequence, but still we had to traverse through the majority of the array.

119
00:10:11,588 --> 00:10:14,731
It's not  we only traversed through four elements.

120
00:10:14,731 --> 00:10:19,696
That would only happen if the subsequence were at the very beginning of the main array.

121
00:10:20,176 --> 00:10:47,805
but also sometimes the subsequence is going to take up the entire main array  for instance before when we didn't have 11 and 7 when we only had the 10 here at the end this subsequence had us go all the way to the end and that's where we found the last element and also if the subsequence isn't contained in the main array  imagine here instead of having these numbers we just had the number I don't know

122
00:10:48,845 --> 00:10:53,888
23, we would have to iterate through the entire array to see that 23 is not contained in it.

123
00:10:53,888 --> 00:11:08,057
So all that to say the time complexity is best described here as O of n, where n is the length of the main array, even though there will be a few cases where we will do fewer than n iterations or n operations.

124
00:11:08,537 --> 00:11:13,000
Now as far as the space complexity, space complexity is going to be constant.

125
00:11:13,000 --> 00:11:15,081
So it'll be O of 1.

126
00:11:15,081 --> 00:11:24,066
And the reason it's constant is because we're not storing anything extra except for maybe a couple of pointers for our position in the respective arrays.

127
00:11:24,066 --> 00:11:29,409
But we're not storing any other big variables or big pieces of data.

128
00:11:29,409 --> 00:11:36,894
And more specifically, we're not storing anything that is going to increase in size with respect to the size of the two inputs.

129
00:11:37,494 --> 00:11:43,781
So with that, let's jump into the code walkthrough to see what this looks  in code.

130
00:11:43,781 --> 00:11:47,745
All , so we've got our validate subsequence function defined.

131
00:11:47,745 --> 00:11:55,374
It takes in two non-empty arrays of integers where the second array is a potential subsequence of the first array.

132
00:11:55,374 --> 00:11:58,037
And we're actually going to cover two code solutions here.

133
00:11:58,457 --> 00:12:22,515
They both have the same overarching logic, the logic that we covered in the conceptual overview of this video, but the first solution is going to use a while loop to traverse through both arrays in tandem and is going to keep track of the positions that we're at in both arrays, whereas the second solution is going to use a for loop to traverse through the main array and is going to keep track of our position only in the second array.

134
00:12:22,935 --> 00:12:26,157
So let's jump into the first solution, the one with the while loop.

135
00:12:26,157 --> 00:12:30,981
For this solution,  I said, we're going to need to keep track of our position in both arrays.

136
00:12:30,981 --> 00:12:38,446
So we're going to declare our array idx, which is going to be initialized to zero, and this is going to be our position in the main array.

137
00:12:38,446 --> 00:12:44,290
And then we're going to have our sequence idx also initialized to zero, our position in the sequence array.

138
00:12:45,030 --> 00:12:55,465
and our while loop is basically going to perform some operations, we'll cover the operations in a second, so long as we are in bounds of both the main array and the sequence array.

139
00:12:55,990 --> 00:13:08,620
So while our array idx is smaller than the length of our array, and while our sequence idx is smaller than the length of our sequence, we're going to perform some stuff.

140
00:13:08,620 --> 00:13:09,641
What are we going to perform?

141
00:13:09,641 --> 00:13:10,661
What are we going to do?

142
00:13:10,661 --> 00:13:19,048
Well, we're looking to see if the element that we are at in the main array is equal to the element that we're at in the sequence array.

143
00:13:19,388 --> 00:13:19,528
?

144
00:13:19,528 --> 00:13:25,693
We're specifically looking to find or to match the current element in the sequence.

145
00:13:25,693 --> 00:13:41,845
So we're going to say if our array at r idx is equal to our sequence at sequence idx, if that's the case, then we found our current element in the sequence and we're going to move our position in the sequence forward by one.

146
00:13:42,245 --> 00:13:44,866
So we're going to increment our sequence idx by 1.

147
00:13:44,866 --> 00:13:58,714
And then regardless of whether this condition is true, so regardless of whether or not we have a match between our current number in the main array and in the sequence array, we are going to keep moving forward in the main array.

148
00:13:58,714 --> 00:14:03,557
So regardless of this condition, we are going to increment our array idx by 1.

149
00:14:03,557 --> 00:14:11,041
And that means that we're going to keep moving along in the main array and in the sequence array we'll move along only if we found a match.

150
00:14:11,721 --> 00:14:20,766
Eventually, we're going to break out of this while loop either because we are going to have traversed the entire sequence or because we're going to have traversed the entire array or both.

151
00:14:20,766 --> 00:14:26,570
And in that case, we're going to return whether or not we have found a valid subsequence.

152
00:14:26,570 --> 00:14:27,710
How do we know that?

153
00:14:27,710 --> 00:14:40,238
Well, if we've traversed through the entire sequence by the end of this while loop, then we found a valid subsequence because that means that we will have hit and satisfied this if condition here

154
00:14:41,455 --> 00:14:51,220
m times, where m is the length of the sequence, and therefore we will have matched all elements in the sequence and we will have a valid subsequence.

155
00:14:51,220 --> 00:14:58,623
So we will only have a valid subsequence if the sequence idx is equal to the length of the sequence.

156
00:14:59,123 --> 00:15:21,879
If we're ever at a point here after this while loop where the sequence idx is smaller than the length of the sequence, either we're still at the very beginning or maybe even we're at the very last element, maybe we're at len of sequence minus one here, well if that's the case, we clearly didn't find all of the sequence elements in the main array and we do not have a valid subsequence.

157
00:15:21,879 --> 00:15:26,242
So here we want to return sequence idx is equal to the length of the sequence.

158
00:15:27,122 --> 00:15:40,127
So  I said in the conceptual overview of this video, this algorithm is going to run in O of n time, where n is the length of our main array, and it's going to run in O of 1 space.

159
00:15:40,127 --> 00:15:43,348
And you can see the space complexity very clearly, ?

160
00:15:43,348 --> 00:15:49,510
All that we store are these two variables here, nothing that increases with the size of the inputs.

161
00:15:49,510 --> 00:15:51,011
And as far as the time complexity,

162
00:15:51,791 --> 00:15:58,136
You can see here that we are going through the entire array with this while loop.

163
00:15:58,136 --> 00:16:01,078
And once we reach the end, we break out of it, and we're done.

164
00:16:01,078 --> 00:16:05,301
We might break early if the sequence is smaller, but we're not sure.

165
00:16:05,301 --> 00:16:12,126
And there are many times when, for instance, we're not going to have a valid subsequence when we're going to have to go through the end of the array.

166
00:16:12,126 --> 00:16:18,511
So the most accurate way of describing this time complexity is going to be O of n, where n is the length of the array.

167
00:16:18,731 --> 00:16:22,752
, on average, or in the worst case, it's going to be O then.

168
00:16:22,752 --> 00:16:25,432
So this is the solution that uses a while loop.

169
00:16:25,432 --> 00:16:27,993
Now let's cover the solution with a for loop.

170
00:16:27,993 --> 00:16:29,213
So we'll copy the code.

171
00:16:29,213 --> 00:16:30,993
I guess we'll comment it out first.

172
00:16:30,993 --> 00:16:34,434
We'll copy the code and delete most of it.

173
00:16:34,434 --> 00:16:42,995
The one thing that we'll keep is the sequence IDX initialized to zero, because we're still going to keep track of our position in the sequence with this pointer.

174
00:16:42,995 --> 00:16:48,036
But instead of a while loop with the array IDX pointer, we're just going to do a for loop through the array.

175
00:16:48,396 --> 00:16:51,598
So we'll say for value in our array.

176
00:16:51,598 --> 00:16:57,600
And here we're going to do a similar check as we had here on line six with the if statement.

177
00:16:57,600 --> 00:17:05,864
We're going to say if our sequence at the sequence IDX is equal to our value, then we have a match, ?

178
00:17:05,864 --> 00:17:07,925
It's the same sort of logic as here.

179
00:17:08,285 --> 00:17:09,807
We have a match, and what do we want to do?

180
00:17:09,807 --> 00:17:12,649
We want to increase our sequence idx.

181
00:17:12,649 --> 00:17:16,033
We'll say sequence idx plus equal to 1.

182
00:17:16,033 --> 00:17:25,802
However, the one thing that we want to do here, since we don't have our while loop that's going to break if we're out of bounds with the sequence, is we want to add this condition

183
00:17:26,463 --> 00:17:27,904
inside of our for loop.

184
00:17:27,904 --> 00:17:42,172
So before we actually do this if statement here, which would probably cause an error because we might be accessing something out of bounds, we want to have this condition that is going to say if our sequence idx is equal to the length of the sequence here,

185
00:17:42,852 --> 00:18:12,418
then we break  we break out of our for loop so we're essentially mimicking this while loop condition here and then if we break out of our for loop we just return the same thing sequence idx is equal to the length of the sequence and of course here you don't even need to break you could just return true in this case because if our sequence idx is equal to the length of the sequence then we've got a valid subsequence but we're going to check this here at the very end anyway so i just  to break here

186
00:18:12,958 --> 00:18:13,959
up to you.

187
00:18:13,959 --> 00:18:18,441
As far as the complexity analysis for this solution, it's going to be identical to the first one.

188
00:18:18,441 --> 00:18:20,842
So I'm just going to go ahead and copy that here.

189
00:18:20,842 --> 00:18:23,703
And the reason it's identical is because we're doing the same logic, ?

190
00:18:23,703 --> 00:18:27,785
We're only storing one variable here with our index.

191
00:18:27,785 --> 00:18:30,706
We're iterating through our array here and keeping track of the value.

192
00:18:30,706 --> 00:18:35,168
We're not storing anything with respect to the size of the input.

193
00:18:35,168 --> 00:18:38,810
And as far as the time complexity, we're really just doing a for loop through the array.

194
00:18:38,810 --> 00:18:41,571
So it's going to be, oh, then time we might break early.

195
00:18:41,891 --> 00:18:45,718
But we don't really know that on average, or in the worst case, we won't break early.

196
00:18:45,718 --> 00:18:48,283
And that's why it's OVN time.

197
00:18:48,283 --> 00:18:52,551
So with that, I hope that you found this video informative, and I'll see you in the next one.

